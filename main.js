/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GoalTrackerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// goalCalendar.ts
var GoalCalendar = class {
  constructor(container, data, options, onUpdate) {
    this.container = container;
    this.data = data;
    this.options = options;
    this.onUpdate = onUpdate;
    this.currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    this.currentMonth = (/* @__PURE__ */ new Date()).getMonth();
  }
  render() {
    this.container.empty();
    this.container.createEl("h3", {
      text: this.options.title,
      cls: "goal-tracker-title"
    });
    this.renderCalendarControls();
    switch (this.options.type) {
      case "monthly":
        this.renderMonthlyView();
        break;
      case "weekly":
        this.renderWeeklyView();
        break;
      case "daily":
      default:
        this.renderDailyView();
    }
  }
  renderMonthlyView() {
    var _a;
    const container = this.container.createEl("div", {
      cls: "goal-tracker-calendar monthly"
    });
    for (let month = 0; month < 12; month++) {
      const monthStr = (month + 1).toString().padStart(2, "0");
      const dateString = `${this.currentYear}-${monthStr}`;
      const isCompleted = (_a = this.data.goals[dateString]) != null ? _a : false;
      const monthEl = container.createEl("div", {
        cls: `calendar-cell ${isCompleted ? "completed" : ""}`,
        text: new Date(2024, month).toLocaleString("default", {
          month: "short"
        })
      });
      monthEl.addEventListener("click", async () => {
        this.data.goals[dateString] = !isCompleted;
        await this.onUpdate(this.data);
        monthEl.toggleClass("completed", !isCompleted);
      });
    }
  }
  renderWeeklyView() {
    var _a;
    const container = this.container.createEl("div", {
      cls: "goal-tracker-calendar weekly"
    });
    const firstDay = new Date(this.currentYear, this.currentMonth, 1);
    const lastDay = new Date(this.currentYear, this.currentMonth + 1, 0);
    let currentDate = new Date(firstDay);
    const dayOfWeek = currentDate.getDay();
    currentDate.setDate(
      currentDate.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1)
    );
    while (currentDate <= lastDay) {
      const weekEnd = new Date(currentDate);
      weekEnd.setDate(weekEnd.getDate() + 6);
      const weekNum = this.getWeekNumber(currentDate);
      const weekYear = this.getWeekYear(currentDate);
      const weekMiddle = new Date(currentDate);
      weekMiddle.setDate(weekMiddle.getDate() + 3);
      const belongsToThisMonth = weekMiddle.getMonth() === this.currentMonth && weekMiddle.getFullYear() === this.currentYear;
      if (belongsToThisMonth) {
        const weekEl = container.createEl("div", { cls: "week-row" });
        const dateString = `${weekYear}-W${weekNum}`;
        const isCompleted = (_a = this.data.goals[dateString]) != null ? _a : false;
        const dateRange = `${currentDate.getDate()} ${currentDate.toLocaleString(
          "default",
          { month: "short" }
        )} - ${weekEnd.getDate()} ${weekEnd.toLocaleString("default", {
          month: "short"
        })}`;
        const weekInfo = weekEl.createEl("div", { cls: "week-info" });
        weekInfo.createEl("span", {
          text: `Week ${weekNum}`,
          cls: "week-number"
        });
        weekInfo.createEl("span", { text: dateRange, cls: "week-dates" });
        const cell = weekEl.createEl("div", {
          cls: `calendar-cell ${isCompleted ? "completed" : ""}`
        });
        cell.addEventListener("click", async () => {
          this.data.goals[dateString] = !isCompleted;
          await this.onUpdate(this.data);
          cell.toggleClass("completed", !isCompleted);
        });
      }
      currentDate.setDate(currentDate.getDate() + 7);
    }
  }
  renderDailyView() {
    var _a;
    const container = this.container.createEl("div", {
      cls: "goal-tracker-calendar"
    });
    const weekdays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    const headerRow = container.createEl("div", {
      cls: "calendar-row"
    });
    weekdays.forEach((day) => {
      headerRow.createEl("div", { cls: "calendar-cell header", text: day });
    });
    const firstDay = new Date(this.currentYear, this.currentMonth, 1);
    const lastDay = new Date(this.currentYear, this.currentMonth + 1, 0);
    const totalDays = lastDay.getDate();
    const startingDay = firstDay.getDay();
    let currentRow = container.createEl("div", { cls: "calendar-row" });
    for (let i = 0; i < startingDay; i++) {
      currentRow.createEl("div", { cls: "calendar-cell empty" });
    }
    for (let day = 1; day <= totalDays; day++) {
      if ((day + startingDay - 1) % 7 === 0 && day !== 1) {
        currentRow = container.createEl("div", { cls: "calendar-row" });
      }
      const dateString = `${this.currentYear}-${(this.currentMonth + 1).toString().padStart(2, "0")}-${day.toString().padStart(2, "0")}`;
      const isCompleted = (_a = this.data.goals[dateString]) != null ? _a : false;
      const cell = currentRow.createEl("div", {
        cls: `calendar-cell ${isCompleted ? "completed" : ""}`,
        text: day.toString()
      });
      cell.addEventListener("click", async () => {
        this.data.goals[dateString] = !isCompleted;
        await this.onUpdate(this.data);
        cell.toggleClass("completed", !isCompleted);
      });
    }
  }
  getWeekYear(date) {
    const d = new Date(date);
    d.setDate(d.getDate() + 3 - (d.getDay() + 6) % 7);
    return d.getFullYear();
  }
  getWeekNumber(date) {
    const target = new Date(date.valueOf());
    const dayNr = (date.getDay() + 6) % 7;
    target.setDate(target.getDate() - dayNr + 3);
    const firstThursday = target.valueOf();
    target.setMonth(0, 1);
    if (target.getDay() !== 4) {
      target.setMonth(0, 1 + (4 - target.getDay() + 7) % 7);
    }
    return 1 + Math.ceil((firstThursday - target.valueOf()) / 6048e5);
  }
  renderCalendarControls() {
    const controls = this.container.createEl("div", {
      cls: "goal-tracker-controls"
    });
    const prevButton = controls.createEl("button", { text: "\u2190" });
    const yearSpan = controls.createEl("span", {
      text: this.currentYear.toString(),
      cls: "year-display"
    });
    const nextButton = controls.createEl("button", { text: "\u2192" });
    if (this.options.type === "monthly") {
      prevButton.addEventListener("click", () => {
        this.currentYear--;
        yearSpan.textContent = this.currentYear.toString();
        this.render();
      });
      nextButton.addEventListener("click", () => {
        this.currentYear++;
        yearSpan.textContent = this.currentYear.toString();
        this.render();
      });
      return;
    }
    const monthSelect = controls.createEl("select");
    const months = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    months.forEach((month, index) => {
      const option = monthSelect.createEl("option", {
        text: month,
        value: index.toString()
      });
      if (index === this.currentMonth) {
        option.selected = true;
      }
    });
    monthSelect.addEventListener("change", (e) => {
      this.currentMonth = parseInt(e.target.value);
      this.render();
    });
    prevButton.addEventListener("click", () => {
      if (this.currentMonth === 0) {
        this.currentMonth = 11;
        this.currentYear--;
      } else {
        this.currentMonth--;
      }
      monthSelect.value = this.currentMonth.toString();
      yearSpan.textContent = this.currentYear.toString();
      this.render();
    });
    nextButton.addEventListener("click", () => {
      if (this.currentMonth === 11) {
        this.currentMonth = 0;
        this.currentYear++;
      } else {
        this.currentMonth++;
      }
      monthSelect.value = this.currentMonth.toString();
      yearSpan.textContent = this.currentYear.toString();
      this.render();
    });
  }
};

// main.ts
var GoalTrackerPlugin = class extends import_obsidian.Plugin {
  async onload() {
    this.registerMarkdownCodeBlockProcessor(
      "goal-calendar",
      async (source, el, ctx) => {
        let calendarData;
        let options = {
          type: "daily",
          title: "Goal Tracker"
        };
        try {
          const lines = source.trim().split("\n");
          while (lines.length > 0 && lines[0].includes(":")) {
            const [key, value] = lines[0].split(":");
            const trimmedKey = key.trim();
            const trimmedValue = value.trim();
            if (trimmedKey === "type") {
              options.type = trimmedValue;
            } else if (trimmedKey === "title") {
              options.title = trimmedValue;
            }
            lines.shift();
          }
          const jsonContent = lines.join("\n");
          if (jsonContent.trim()) {
            calendarData = JSON.parse(jsonContent);
          } else {
            calendarData = {
              id: crypto.randomUUID(),
              type: options.type,
              title: options.title,
              goals: {}
            };
          }
          calendarData.title = options.title;
        } catch (e) {
          console.error("Failed to parse calendar data", e);
          calendarData = {
            id: crypto.randomUUID(),
            type: options.type,
            title: options.title,
            goals: {}
          };
        }
        const calendar = new GoalCalendar(
          el,
          calendarData,
          options,
          async (updatedData) => {
            const file = this.app.vault.getAbstractFileByPath(ctx.sourcePath);
            if (!(file instanceof import_obsidian.TFile)) {
              console.error("Could not find source file");
              return;
            }
            const content = await this.app.vault.read(file);
            const sectionInfo = ctx.getSectionInfo(el);
            if (!sectionInfo) {
              console.error("Could not find section info");
              return;
            }
            const newContent = this.updateCalendarBlock(
              content,
              sectionInfo,
              `type: ${options.type}
title: ${options.title}
${JSON.stringify(
                updatedData,
                null,
                2
              )}`
            );
            await this.app.vault.modify(file, newContent);
          }
        );
        calendar.render();
      }
    );
  }
  updateCalendarBlock(content, sectionInfo, newData) {
    const lines = content.split("\n");
    const sectionStart = sectionInfo.lineStart;
    const sectionEnd = sectionInfo.lineEnd;
    const beforeSection = lines.slice(0, sectionStart + 1).join("\n");
    const afterSection = lines.slice(sectionEnd).join("\n");
    return `${beforeSection}
${newData}
${afterSection}`;
  }
};
